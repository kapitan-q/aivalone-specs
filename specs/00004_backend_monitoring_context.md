# Task #00004: Context: Monitoring & Filtering Engine

## 1. Контекст и Архитектура
Контекст **Monitoring** отвечает за управление подписками пользователей на группы, хранение поисковых фильтров и сопоставление входящих сообщений с этими фильтрами.

Реализуется модель **Shared Ingress** на основе **Карты Пересечений (Intersection Map)**: одна группа прослушивается одной оптимальной сессией, даже если на неё подписано множество пользователей.

### Основной поток (Data Flow):
1. **Command**: Пользователь настраивает фильтр. Если группа новая — отправляется команда в Python-сервис на прослушивание `chat_id`.
2. **Ingress**: Python-сервис транслирует сообщения из группы в шину (Message Broker).
3. **Processing**: Monitoring Context ловит сообщение, находит **все** активные фильтры для этой группы и выполняет сверку.
4. **Egress**: При совпадении отправляется команда в **Bot Context** для уведомления пользователя с цитированием сообщения.

## 2. Цели задачи
1. **Минимизация ресурсов**: Обеспечить прослушивание одной группы только одной сессией, независимо от количества подписанных пользователей.
2. **Отказоустойчивость (Failover)**: Реализовать механизм автоматического переключения на резервную сессию при потере доступа основной, чтобы мониторинг не прерывался.
3. **Гибкая фильтрация**: Создать движок, поддерживающий три уровня поиска: обычный (подстрока), морфологический и семантический (AI) (на данной стадии реализуем "обычный", для остальных предусматриваем слой абстракций, чтобы в дальнейшем можно было добавить их без существенных изменений существующей логики).
4. **Масштабируемость Ingress**: Реализовать равномерное распределение публичных каналов по пулу сервисных аккаунтов.
5. **Бесшовная интеграция**: Наладить стабильный обмен командами и событиями с Python-сервисом и Bot-контекстом.

## 3. Компоненты системы

### 3.1. Domain: Filtering & Subscriptions
- **Filter**: Сущность (владелец, `chat_id`, ключевые слова, флаг работы, стратегия поиска: Simple/Morpho/AI).
- **Session**: Сессия (API Hash, Session String). Тип: `System` (сервисный) или `User` (пользовательский), сессия привязана к конкретному пользователю, у 1 пользователя может быть несколько сессий.
- **GroupConnection**: Связка `Session` <-> `ChatId`. Хранит статус доступа конкретного аккаунта к конкретной группе (Active, Broken, Left).
- **Intersection Map (Logic)**: Карта пересечений, определяющая, какие сессии имеют доступ к каким группам.

### 3.2. Infrastructure: Integration Bridge
- **PythonServiceGateway**: Отправляет команды в Python-сервис (через RabbitMQ/Redis) на старт/стоп мониторинга (**PythonServiceGateway** переименовать).
- **IncomingMessageConsumer**: Слушатель «сырых» сообщений из Telegram.

## 4. Логика работы с сессиями и Failover

### 4.1. Типы источников
- **SystemSession (Public)**: Группы распределяются равномерно между сервисными аккаунтами. При добавлении новой публичной группы выбирается сессия с наименьшей нагрузкой. Если группа отсутствует в подписках сервисного аккаунта, отправляется команда на автоматическое присоединение (Join).
- **UserSession (Private)**: Индивидуальная сессия. Используется для групп, доступных только конкретному пользователю.

### 4.2. Управление подписками и пулами
- **Единая подписка**: Если на одну группу подписаны несколько пользователей, Python-сервис получает команду на прослушивание через **одну** выбранную сессию из пула доступных (Intersection Map).
- **Логика пересчета при сбое**:
    - При получении сигнала от Python о потере доступа (пользователь покинул группу, отозвал доступ), данная связка `GroupConnection` деактивируется.
    - Система выполняет мгновенный пересчет: ищет в карте пересечений следующую доступную сессию (сервисную или другого пользователя) для этой группы.
    - Если сессия найдена — отправляется команда в Python на переключение источника прослушивания.
    - Пользователь которому принадлежала сессия перестает получать сообщения из данной группы, пользователь уведомляется об этом.
    - Если сессий больше нет — мониторинг группы останавливается, все пользователи, мониторящие эту группу, уведомляются.
- **Деактивация пользователя**: При выходе пользователя или отзыве авторизации все связанные с ним `GroupConnection` аннулируются. Выполняется пересчет для всех затронутых групп, чтобы переключить их на другие сессии или остановить прослушивание.

## 5. План реализации

### Шаг 0: Схема данных
- Пользователь может иметь несколько сессий, Каждая сессия может иметь доступ к нескольким группам.
- При мониторинге сообщений группы составляется пересечение, чтобы получать сообщения через одну сессию и уведомлять всех пользователей мониторящих ее.
- Есть сервисный пользователь с несколькими сессиями для отслеживания публичных групп

### Шаг 1: Хранилище и Карта пересечений
- Реализация сущностей `Filter`, `Session`, `Group` и `GroupConnection` (имена сущностей примерные).
- Логика равномерного распределения публичных каналов между сервисными сессиями (балансировщик нагрузки).

### Шаг 2: Взаимодействие с Python-сервисом
- Контракт команды: `{chat_id, primary_session_data, backup_sessions_pool[]}`.
- Реализация **Join Queue**: Очередь на вступление сервисных аккаунтов в группы с временными задержками для защиты от антифрод-систем Telegram.

### Шаг 3: Двигатель фильтрации (Matching Engine)
- Реализация `BroadcastMatcher`: одно входящее сообщение сопоставляется со всеми фильтрами группы за один цикл обработки.
- Поддержка стратегий поиска: Simple (подстрока), Morpho (базовый тариф, учет морфологии), AI (Premium, семантика).

### Шаг 4: Интеграция с Bot Context
- Формирование команды `SendNotificationCommand` с метаданными для цитирования и ссылкой на оригинал.
- Система уведомлений пользователя о проблемах с его личной сессией или выходе из группы.

## 6. Definition of Done
- [ ] Группа подписывается один раз и уведомляет нескольких пользователей одновременно.
- [ ] Публичные каналы распределяются среди сервисных аккаунтов равномерно.
- [ ] Реализован автоматический пересчет и выбор новой сессии из пула при сбое основной.
- [ ] При выходе пользователя из системы его сессия деактивируется, а связанные группы переключаются на другие доступные аккаунты.
- [ ] Сообщения отфильтровываются согласно тарифному плану пользователя.

## 7. Риски
- **Лимиты Telegram**: Риск бана сервисных аккаунтов при массовых подписках. Требуется строгий контроль через `Join Queue`.
- **Консистентность**: Необходимость ежедневной сверки (инвентаризации) реального списка групп в Telegram-сессиях и данных в БД Symfony.