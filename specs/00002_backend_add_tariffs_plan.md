# Task #00002: Backend: Subscriptions (Billing) & Permissions (Account)

## 1. Контекст и Архитектура
Согласно архитектуре проекта, контекст **Account** (Account) отвечает за полномочия пользователя. 
Необходимо реализовать логику тарифных планов так, чтобы система могла жестко ограничивать действия пользователя (количество групп, доступ к AI) на уровне доменной модели.
Реализуется модель **наслаиваемых подписок**. Пользователь может иметь несколько одновременно активных подписок (например, вечный `Free` + месячный `Base`).

Разделение зон ответственности:
- **Billing Context**: Владелец бизнес-логики (тарифы, цены, транзакции, сроки). Хранит историю и текущие активные планы.
- **Account Context**: Операционная проверка прав (хранит (Snapshot) всех активных прав, полученный в результате слияния (Merge) активных подписок).
- **Shared Domain**: Общая механика проверки прав (Smart Options) и контракты.

## 2. Цели задачи
1. Реализовать справочник тарифов и подписок в **Billing** с уникальными наборами опций.
2. Реализовать поддержку нескольких активных сущностей `Subscription` для одного пользователя.
3. Ввести понятие `Priority` для тарифов для корректного слияния опций.
4. Реализовать механизм **Permissions Aggregator** в Billing, который формирует итоговый набор прав.
5. Создать **PermissionsTrait** в Shared для унификации метода `can()` во всех контекстах.
6. Настроить синхронизацию через события и консольную команду деактивации.
7. Документировать архитектуру проверки прав в корневом `README.md` бэкенда.

## 3. Компоненты системы

### 3.1. Shared Domain: Permission Engine
- **FeatureOptionInterface**: Контракт для стратегий (напр. `MaxGroupFeatureOption`).
- **PermissionsTrait**: Метод `can(string $code, $value)`. Подмешивается в сущность `User` (Account, Bot и т.д.).
- **FeatureRegistry**: Реестр стратегий (через Tagged Services).

### 3.2. Billing: Структура и Жизненный цикл
- **TariffPlan**: Имеет 
    - `название` (напр. "Premium"), 
    - `код` (напр. `PREMIUM_MONTH`), 
    - `priority` (Чем выше число, тем выше приоритет опций при совпадении кодов), 
    - `description` описание
    - `price` цену (может быть `null` для бесплатного тарифа)
- **TariffOption**: 
    - Имеет `название` (напр. "Лимит групп") и `код` (напр. `MAX_GROUP`).
    - Содержит `значение` (напр. `5`), которое интерпретируется классом `FeatureOption`.
    - Это позволяет создавать несколько `TariffOption` с одним кодом `MAX_GROUP`, но разными значениями для разных планов.
- **TariffPlanOption**: связь  `TariffPlan` <-> `TariffOption
- **Ограничения**: В связке `TariffPlan` <-> `TariffOption` код опции должен быть **уникальным**. Один тариф не может иметь две разные опции `MAX_GROUP`.
- **Subscription**: Запись о подписке. Не заменяется при покупке новой, а создается рядом.` 
- **Permission Aggregator (Service)**:
    - Выбирает все `Subscription` пользователя, где `expires_at > now`.
    - Сортирует их по `TariffPlan.priority`.
    - Сливает `TariffOption` в единый массив (опции с высшим приоритетом перезаписывают низшие).
    - Генерирует событие `UserPermissionsUpdatedEvent` с итоговым JSON.
- **Entities**: `TariffPlan`, `TariffOption`, `Subscription`.
- **Events**:
    - `SubscriptionActivatedEvent`: Выбрасывается при покупке.
    - `SubscriptionExpiredEvent`: Выбрасывается при наступлении даты `expires_at`.
    - `UserPermissionsUpdatedEvent`: при изменении подписки (истечение срока, добавление новой, деактивация, удаление)
- **Console Command (`app:billing:check-expiration`)**: 
    - Раз в час находит подписки, срок которых истек.
    - Вызывает метод подписки `checkExpirationTime`, в котором выбрасывается события для уведомления пользователя
        - `SubscriptionExpiredEvent` - если срок подписки истек
        - `SubscriptionExpiringSoonEvent` - За 3 дня до истечения (настраивается, может быть несколько периодов, например 7-3-1 день) для уведомления пользователя, 
           нужно предусмотреть чтобы данное событие отправлялось один раз за указанный период, а не при каждом вызове этого метода.
        - 
- **Presentation**: необходимо реализовать api контроллер для frontend для получения списка тарифов и их опций.

### 3.3. Account
- **User Entity**: Использует `PermissionsTrait`. Содержит `permissions` (JSON кэш).
- **Event Handlers**: Идемпотентное обновление кэша разрешений при получении событий от Billing.

## 4. План реализации

### Шаг 1: Shared Framework
- Реализовать интерфейс опций и базовые классы (Boolean, Numeric) согласно Readme.
- Создать `PermissionsTrait` и `FeatureRegistry`.

### Шаг 2: Billing Infrastructure & DataFixtures
- Создать сущности `TariffPlan`, `TariffOption`, `Subscription`.
- Настроить уникальные индексы на связку `tariff_id + option_code`.
- **DataFixtures**: Реализовать сидеры для создания тарифной сетки, описанной в корневом `Readme.md` проекта.

### Шаг 3: Event Bridge & Documentation
- Описать DTO событий в Shared.
- **README Backend**: Добавить раздел "Система проверки прав", описывающий взаимодействие Billing, Account и Shared, а также список доступных `FeatureOption` кодов.

### Шаг 4: Account Integration
- Подключить `PermissionsTrait` к `User`.
- Реализовать логику `Free` тарифа по умолчанию при регистрации.
- Реализовать хэндлеры синхронизации.

## 5. Definition of Done
- [ ] Следование парадигме DDD, каждый контекст отделен от другого и нет кроссимпортов между ними (за исключением Shared).
- [ ] Сущность `User` проверяет права через `can()`.
- [ ] Сидеры создают корректную тарифную сетку.
- [ ] Попытка добавить две одинаковые опции в один тариф блокируется на уровне БД/Валидации.
- [ ] Описание системы прав добавлено в `backend/README.md`.
- [ ] Консольная команда деактивации работает и инициирует сброс прав в Account через событие.
- [ ] Событие об истечении корректно обрабатывается в Account, переводя пользователя на Free-лимиты.
- [ ] SQL-запросы контекста Account не обращаются к таблицам Billing.
- [ ] Написаны Unit-тесты на логику трейта и классов опций.

## 6. Риски
- **Нарушение уникальности**: Если в тариф попадет две опции с одним кодом, метод `can()` вернет непредсказуемый результат. Требуется строгий `UniqueConstraint`.
- **Сложность отладки**: При наслоении 5+ подписок сложно понять, почему `can()` вернул `false`. Решается детальным логированием процесса агрегации в Billing.
- **Синхронизация**: При падении очереди сообщений возможна временная рассинхронизация (пользователь сохранит права дольше положенного). Решается повторным запуском (retry) сообщений.