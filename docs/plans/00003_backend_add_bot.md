# Task #00004: Context: Bot & Conversation Engine (FSM)

## 1. Контекст и Архитектура
Контекст **Bot** отвечает за прием сообщений, их маршрутизацию и управление состоянием диалога. 
Основная концепция — **Conversation (Диалог)**. Бот не просто отвечает на команду, он ведет пользователя по сценарию (Step-by-step), сохраняя прогресс между запросами.

### Принципы:
- **Platform Agnostic**: Логика диалогов отделена от мессенджера интерфейсом `BotInterface` и `Request/Response` DTO.
- **Stateful**: Состояние пользователя (текущий шаг диалога и временные данные) хранится в базе данных (Redis или SQL).
- **Declarative Steps**: Сценарий описывается как набор методов-шагов или конфигурация переходов.

## 2. Цели задачи
1. Создать абстракцию **Conversation**, управляющую последовательностью действий.
2. Реализовать хранилище состояний (**State Storage**) для отслеживания позиции пользователя в диалоге.
3. Интегрировать готовую библиотеку для работы с Telegram на инфраструктурном уровне.
4. Обеспечить доступ к проверке прав пользователя через `PermissionsTrait` внутри бота.

## 3. Компоненты системы

### 3.1. Domain: Conversation Engine
- **ConversationInterface**: Описывает жизненный цикл разговора (`start`, `next`, `handle`, `isFinished`).
- **AbstractConversation**: Базовый класс, реализующий логику переключения шагов. Каждый шаг — это отдельный метод (напр., `askName`, `validateName`, `saveProfile`).
- **StateEntity**: Объект, хранящий:
    - `userId` (связка с Account Context)
    - `conversationClass` (имя текущего сценария)
    - `currentStep` (индекс или имя шага)
    - `contextData` (JSON с временно введенными данными).

### 3.2. Infrastructure: Messenger Integration
- **TelegramAdapter**: Реализация `BotInterface` на базе Open Source решения (рекомендуется **nutgram/nutgram** или **php-telegram-bot/core** за их поддержку Symfony и встроенные механизмы диалогов/FSM).
- **BotRouter**: Принимает входящий Webhook/Longpoll, определяет, находится ли пользователь в активном диалоге, и направляет запрос либо в диалог, либо в обработчик одиночных команд.

### 3.3. Application: Services
- **ConversationManager**: Сервис для запуска новых диалогов и восстановления существующих из БД.

## 4. План реализации

### Шаг 1: Инфраструктурный слой
- Установка и настройка Telegram SDK (Nutgram).
- Настройка Webhook и контроллера для приема обновлений.
- Создание `BotRequest` и `BotResponse` DTO для изоляции домена от SDK.

### Шаг 2: Conversation Framework (Domain)
- Реализация `AbstractConversation` с поддержкой декларативных шагов.
- Реализация **State Storage** (Doctrine репозиторий для хранения состояний диалога в БД).

### Шаг 3: Интеграция с Account Context
- Реализовать Middleware/Interceptor, который по `telegram_id` находит пользователя, проверяет его права через `User::can()` и блокирует доступ к диалогу, если лимиты превышены.

### Шаг 4: Тестовый сценарий
- Создать пример диалога `AddGroupConversation`:
    1. Шаг: Запросить ссылку на группу.
    2. Шаг: Проверить валидность ссылки.
    3. Шаг: Подтвердить добавление и завершить.

## 5. Definition of Done
- [ ] Бот успешно принимает сообщения и понимает команды.
- [ ] Реализована поддержка многошаговых диалогов (состояние сохраняется при перезагрузке сервера).
- [ ] Логика диалога не содержит прямых вызовов методов Telegram SDK (используются абстракции).
- [ ] Перед запуском диалога происходит проверка прав пользователя (`Account Context`).
- [ ] Код диалогов покрыт Unit-тестами (эмуляция ввода пользователя).

## 6. Технологический стек
- **SDK**: [Nutgram](https://github.com/nutgram/nutgram) (современный, поддерживает FSM и Conversations из коробки).
- **Storage**: PostgreSQL (для персистентных диалогов) или Redis (для быстрых/временных).